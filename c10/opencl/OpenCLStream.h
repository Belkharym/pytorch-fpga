#pragma once

#include <c10/core/DeviceGuard.h>
#include <c10/macros/Macros.h>
#include <c10/opencl/OpenCLMacros.h>
#include <c10/util/Exception.h>
#include <c10/core/Stream.h>

/*
* OpenCLStream is a wrapper of an instance of cl_command_queue.
*/

namespace c10 {
namespace opencl {

class C10_API OpenCLStream {
public:

  enum Unchecked { UNCHECKED };

  /// Construct a OpenCLStream from a Stream.  This construction is checked,
  /// and will raise an error if the Stream is not, in fact, an OpenCL stream.
  explicit OpenCLStream(Stream stream) : stream_(stream) {
    TORCH_CHECK(stream_.device_type() == DeviceType::OPENCL);
  }

  /// Construct a OpenCLStream from a Stream with no error checking.
  /// This constructor uses the "named" constructor idiom, and can
  /// be invoked as: OpenCLStream(OpenCLStream::UNCHECKED, stream)
  explicit OpenCLStream(Unchecked, Stream stream) : stream_(stream) {}

  bool operator==(const OpenCLStream& other) const noexcept {
    return unwrap() == other.unwrap();
  }

  bool operator!=(const OpenCLStream& other) const noexcept {
    return unwrap() != other.unwrap();
  }

  operator cl::CommandQueue*() const { return stream(); };

  operator Stream() const { return unwrap(); };

  /// Get the CUDA device index that this stream is associated with.
  DeviceIndex device_index() const { return stream_.device_index(); }

  /// Get the full Device that this stream is associated with.  The Device
  /// is guaranteed to be a CUDA device.
  Device device() const { return Device(DeviceType::OPENCL, device_index()); }

  /// Return the stream ID corresponding to this particular stream.
  StreamId id() const { return stream_.id(); }

  void synchronize() const {
    DeviceGuard guard{stream_.device()};
    TORCH_CHECK(clFinish((*stream())()));
  }

  /// Reversibly pack a OpenCLStream into a uint64_t representation.  This may
  /// be helpful when storing a OpenCLStream in a C struct, where you cannot
  /// conveniently place the OpenCLStream object itself (which is morally
  /// equivalent, but unfortunately is not POD due to the fact that it
  /// has constructors.)
  ///
  /// The OpenCLStream can be unpacked using unpack().  The format of
  /// the uint64_t is unspecified and may be changed.
  uint64_t pack() const noexcept {
    return stream_.pack();
  }

  // Unpack a OpenCLStream from the uint64_t representation generated by pack().
  static OpenCLStream unpack(uint64_t bits) {
    return OpenCLStream(Stream::unpack(bits));
  }

  /// Explicit conversion to Stream.
  Stream unwrap() const { return stream_; }

  /// Explicit conversion to CommandQueue_t.
  CommandQueue_t stream() const;

private:
  Stream stream_;
};

/**
 * Get a new stream from the OpenCL stream pool.  You can think of this
 * as "creating" a new stream, but no such creation actually happens;
 * instead, streams are preallocated from the pool and returned in a
 * round-robin fashion.
 *
 * You can request a stream for a specific device by setting device
 * (defaulting to the current OpenCL stream.)
 */
CAFFE2_API OpenCLStream
getStreamFromPool(DeviceIndex device = -1);

/**
 * Get the default OpenCL stream, for the passed OpenCL device, or for the
 * current device if no device index is passed.  The default stream is
 * where most computation occurs when you aren't explicitly using
 * streams.
 */
CAFFE2_API OpenCLStream getDefaultOpenCLStream(DeviceIndex device_index = -1);

/**
 * Get the current OpenCL stream, for the passed OpenCL device, or for the
 * current device if no device index is passed.  The current OpenCL stream
 * will usually be the default OpenCL stream for the device, but it may
 * be different if someone called 'setCurrentOpenCLStream' or used 'StreamGuard'
 * or 'OpenCLStreamGuard'.
 */
CAFFE2_API OpenCLStream getCurrentOpenCLStream(DeviceIndex device_index = -1);

/**
 * Set the current stream on the device of the passed in stream to be
 * the passed in stream.  Yes, you read that right: this function
 * has *nothing* to do with the current device: it toggles the current
 * stream of the device of the passed stream.
 *
 * Confused?  Avoid using this function; prefer using 'OpenCLStreamGuard' instead
 * (which will switch both your current device and current stream in the way you
 * expect, and reset it back to its original state afterwards).
 */
CAFFE2_API void setCurrentOpenCLStream(OpenCLStream stream);

C10_API std::ostream& operator<<(std::ostream& stream, const OpenCLStream& s);

} // namespace opencl
} // namespace c10

namespace std {
  template <>
  struct hash<c10::opencl::OpenCLStream> {
    size_t operator()(c10::opencl::OpenCLStream s) const noexcept {
      return std::hash<c10::Stream>{}(s.unwrap());
    }
  };
} // namespace std
